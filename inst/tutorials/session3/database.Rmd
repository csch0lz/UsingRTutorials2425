---
title: "Session 3: Principles of Database Management"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
    Check your understanding of the tidyverse functions for managing relational data, 
    learn how to wrangle in steps and check each step,
    and continue working on your Data Project.
---

```{r setup, include=FALSE}
# Ensure that libraries are loaded.
library(tidyverse)
library(learnr)
library(gradethis)
library(knitr)
library(kableExtra)

tutorial_options(exercise.timelimit = 60, exercise.checker = gradethis::grade_learnr)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r, context="data", include=FALSE}
# Ensure that the data is loaded for the remainder of this tutorial.
GlasgowFriends <- UsingRTutorials::GlasgowFriends # readr::read_csv("data/GlasgowFriends.csv")
# Create the Student table.
# It is not used in grade_result(), so it may already be around.
Student <- GlasgowFriends |> select(student, neighbourhood, schooldist, hoodname, age, sex, smoking_at_home, smoking_parents, smoking_siblings) |> distinct()
```

<!-- Define programming tip style -->
<style>
.tip {
  background-color: #f5f5f5;
}
</style>

<!-- Define question style -->
<style>
.question {
  color: #5A9DDB;
}
</style>

<!-- Define emphasis style -->
<style>
.emphasis {
  color: #e8301b;
}
</style>

## Overview 

Problem sets discussion

First two hours: Course content

-   Tidy data  
-   Joins (Relational data)

Third hour: Data project

-   Work on Sprint #2. Ask questions as necessary (see schedule).

## Problem Sets Discussion

Feedback to problem sets answers.

## Tidy Data: Eve`R`ything In One Place

Rules for optimal data structure (efficiency and consistency):  

1. Each type of case must have its own tibble (table).  
    + Is the same information repeated in different rows?  
    + Split the tibble; transfer the info on each type of case to a separate tibble.  
    + The book _R for Data Science_ does not discuss this much.

2. Each observation must have its own row.  
    + Do different variables address the same information?  
    + Stack repeated information.  
    + Don't allow values as columns.

3. Each variable must have its own column.  
    + Is there a variable with values that should be variables by themselves? 
    + Don't stack different types of information in the same column.
    + Spread information over different columns.

4. Each value must have its own cell.  
    + Does a variable contain more than one piece of information?
    + Don't cram more than one piece of information in a cell.  
    + Split the variable.

The next four sections of this tutorial discuss these four rules.

## 1. Each type of case must have its own tibble

In this tutorial, we tidy up the very untidy tibble `GlasgowFriends`.

Data arising from practical sources usually contain information about different types of cases, for example:

-   a person; 
-   an organization; 
-   a moment in time;
-   or a combination of these.

For understanding and tidying your data, it is paramount to identify the types of cases in your data.

<div class="emphasis" >
What are you counting or plotting later on: persons, neighbourhoods, persons-per-wave, ...?
</div>

<div class="question" >
Inspect the `GlasgowFriends` tibble or use help on it to identify different types of cases in this data set. For each variable, ask yourself the question: What thing has this characteristic?
</div>

```{r GlasgowFriends, exercise = TRUE}
str(GlasgowFriends)
?GlasgowFriends
```

### 

### Primary key

Potential types of cases in `GlasgowFriends`:

-   __student__: has an age, sex, can be a friend, and so on.
-   __neighbourhood__: has a name, a distance from school.
-   __wave__:  characteristic of neither a student nor a neighbourhood.

```{r}
#Example of observation missing for one student.
data.frame(
  student = c("s001", "s002", "s003", "s004"),
  age = c(13.3, 14.2, 13.5, 13.7),
  friendships = c(4, 2, 3, 6)
  ) |>
  knitr::kable(booktab = TRUE) |> 
  kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

The above data frame with students as cases:

-   has 1 row for each student;
-   variable `student` uniquely identifies a student;
-   this variable is the _primary key_: smallest set of variables for which every case has a unique combination of values.

### 

```{r}
#Example of observation missing for one student.
data.frame(
  student = c("s001", "s002", "s002", "s003"),
  age = c(13.3, 13.5, 14.2, 13.7),
  friendships = c(4, 2, 3, 6)
  ) |>
  knitr::kable(booktab = TRUE) |> 
  kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

<div class="question" >
What is the primary key in the above tibble? Are students the (only) type of cases in this tibble?
</div>

### Primary key as indicator of types of cases

Find the primary key of a data frame to understand the type(s) of cases.

Identifying the primary key of a data frame:

1.    From the data description, chose variables that you think identify types of cases.
2.    Count each unique combination of values on these variables with `count()`.
3.    Check if there are combinations of values that appear more then once with `filter(n > 1)`.
      + If at least one combination of values appears more than once, this set of variables is not a primary key; add a variable to the key (go to Step 1).
      + If no combination of values appears more than once, you may have more variables than the primary key. See if you can remove a variable and still have a unique key (go to Step 2).

<div class="question" >
Write code that identifies the primary key of tibble `GlasgowFriends`. You may have to try out different combinations of variables; submit only the final code for checking. </div>

```{r primarykeyhidden, eval=FALSE}
# primary key: this seems to be the only option with four variables
GlasgowFriends |> 
  count( student, wave, bestfriend, bfperiod ) |> 
  filter(n > 1)
```

```{r primarykey, exercise = TRUE}
# Add the variables in the count() function that you think 
# represent different types of cases (unit).
GlasgowFriends |> 
  count( ____ ) |> 
  filter(n > 1)
```

<div id="primarykey-hint">
__Hint:__ Add the variables in the count() function that you think represent different types of cases (unit).
</div>

```{r primarykey-solution}
GlasgowFriends |> count( student, wave, bestfriend, bfperiod ) |> filter(n > 1)
```

```{r primarykey-check}
gradethis::grade_code(
  correct = "", 
  incorrect = " Well, maybe you just entered the variables in another order than I expected. If the result is 0 and you use just four variables, your have the correct primary key."
  )
```

### Finding the primary key

If you are unsure which variable to add to find the primary key:

-   Select cases with a non-unique combination of values on the variables you selected so far for the primary key. 
-   Compare these cases: Which variable has different values? 
-   This is the variable that you should add to get a primary key.

<div class="question" >
1. Use the code below to find out which variable must be added because it has different values for the first pair of cases that have the same `student` and `wave` values.
2. Add this variable to the code below. Any variable that must still be added to obtain a primary key?
</div>

```{r primarykey2, exercise = TRUE}
# Display cases with the same provisional primary key as consecutive cases.
GlasgowFriends |>
  # (ADD HERE) for each combination of selected primary key variables...
  group_by( student, wave, ____ ) |>
  # ...calculate and add the number of cases with the same values
  mutate(n_identical = n()) |>
  # retain only cases that are not unique on the selected variables
  filter(n_identical > 1) |>
  # (ALSO ADD HERE) sort the cases, so duplicates are next to each other
  arrange( student, wave, ____ ) |> 
  # show only the first two cases that are duplicates
  ungroup() |>
  slice(1:2)
```

### Finding the type of cases for a variable 

Every variable in your primary key and every combination of these variables may represent a different type of cases. 

Example: A primary key consisting of the variables `student` and `wave`.

```{r}
data.frame(
  `Case type` = c("Student/person", "Wave", "Student per wave / wave per student"),
  Variables = c("student, neighbourhood, age, sex, ...", "wave ID", "alcohol, cannabis, tobacco, ..."),
  Notes = c("Fixed student characteristics", "Wave characteristics", "Student characteristics that may change between waves"),
  `Split tibble?` = c("yes", "no (only wave ID)", "yes")
  ) |>
  knitr::kable(booktab = TRUE,
               col.names = c("Case type", "Variables", "Notes", "Separate tibble?")
               ) |> 
  kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

### 

<div class="tip" >
__Tip__

Finding the variables that belong to a type of cases:

1.    Use common sense: The variable is a characteristic of what?
2.    Check that the variable has a unique value for each case of the selected type (use the code below), e.g., for each student or each student/wave combination. 
3. The variable belongs to the simplest type of cases (identified by fewest variables) satisfying the check in Step 2. For example,`age` is fixed per student and per student-wave combination.
</div>

<div class="question" >
For each variable in `GlasgowFriends` determine to which type of case it belongs.
</div>

```{r casetype, exercise = TRUE}
# Code to check that a variable .var. always has the same value for each value
# of the selected type of case .type. . Replace .var. by a variable name and
# replace .type. by the variable(s) that define the type of case.
GlasgowFriends |>
  # For each value of the selected type of case...
  group_by( .type. ) |>
  # ... calculate the number of distinct values of the selected variable.
  summarise(n_distinct = n_distinct( .var. ), .groups = "drop") |>
  # Count number of distinct variable values per type of case: 
  # If 1, then variable has unique value for each case.
  count(n_distinct)
```

```{r casetype-hint-1}
# Example: Checking that variable age is unique for each student-wave combination.
GlasgowFriends |>
  # For each value of the selected type of case...
  group_by( student, wave ) |>
  # ... calculate the number of distinct values of the selected variable.
  summarise(n_distinct = n_distinct( age ), .groups = "drop") |>
  # Count number of distinct variable values per type of case (grouping has been
  # dropped): should always be 1.
  count(n_distinct)
# In the output of this code, 'n_distinct' gives the number of different ages
# encountered per student per wave. Column 'n' gives the number (frequency) of
# student per wave combinations.
```

```{r casetype-hint-2}
# If 'age' is unique for each student-wave combination, it can also be unique for each student. If so, 'age' belongs to the student type of case, not the student per wave type of case.
# Example: Checking that variable age is unique for each student-wave combination.
GlasgowFriends |>
  # For each value of the selected type of case...
  group_by( student ) |>
  # ... calculate the number of distinct values of the selected variable.
  summarise(n_distinct = n_distinct( age ), .groups = "drop") |>
  # Count number of distinct variable values per type of case (grouping has been dropped): should always be 1.
  count(n_distinct)
# In the output of this code, 'n_distinct' gives the number of different ages encountered per student. Column 'n' gives the number (frequency) of students.
```

### 

<div class="tip" >
__Programming Tip__

- Be systematic and precise!
- For example, if a primary key is defined as _the smallest set of variables for which every case has a unique combination of values_, check both parts of the definition: 
    (1) Every case has a unique combination of values,
    (2) and this is the smallest set of variables for which 1 holds.
</div>

### Splitting a tibble

<div class="emphasis" >
Tidy Rule 1. Each type of case must have its own tibble
</div>

Create a separate tibble for each type of case.

This way, each piece of information is stored only once:

- No notational variations, e.g., a person's ID number cannot be different in different cases.
- Easy editing/updating: change/add a value only in one place.
- Max storage efficiency: no repetition of information.
- Information is stored by type of cases: easier to find.
- Any multilevel structure of the data (for statistical analysis) is clear from the presence of different tibbles.

### 

<div class="question" >
Use your data wrangling skills from Session 2 and the data transformation with dplyr cheat sheet to create a tibble for each type of case in `GlasgowFriends`:

1. Student.
</div>

```{r studenttable, exercise = TRUE, exercise.lines = 6}
# Your code to create a tibble for student information without duplicates.
Student <- GlasgowFriends |> 
  # select the relevant variables
  select( ____ ) |> 
  # only keep cases that are distinct (not identical)
  distinct()
```

<!-- To hide the solution, use a textual hint. -->
<div id="studenttable-hint">
__Hint:__ For now, include the neighbourhood variables in the Student tibble.
</div>

```{r studenttable-solution}
Student <- GlasgowFriends |> select(student, neighbourhood, schooldist, hoodname, age, sex, smoking_at_home, smoking_parents, smoking_siblings) |> distinct()
```

```{r studenttable-check}
gradethis::grade_result(
  pass_if(~ {nrow(.result) == 160 && ncol(.result) == 9 }, "Indeed, student, bestfriend, bfperiod, and bfwave belong together in this tibble."),
  fail_if(~ nrow(.result) != 160, "The number of cases in the new tibble is not correct. You did not select the correct variables."),
  fail_if(~ ncol(.result) != 9, "The number of variables in the new tibble is not correct. You did not select (all) correct variables.")
)
```

### 

<div class="question" >
2. StudentWave.
</div>

```{r studentwavetable, exercise = TRUE, exercise.lines = 6}
# Your code to create a tibble for student per wave information without duplicates.
StudentWave <- GlasgowFriends |> 
  # select the relevant variables
  select( ____ ) |> 
  # only keep cases that are distinct (not identical)
  distinct()
```

<!-- To hide the solution, use a textual hint. -->
<div id="studentwavetable-hint">
__Hint:__ It is a good custom to use the primary key variables as the first variables in a tibble.
</div>

```{r studentwavetable-solution}
StudentWave <- GlasgowFriends |> select(student, wave, alcohol, cannabis, money, romantic, friend_1, friend_2, friend_3, friend_4, friend_5, friend_6 ) |> distinct()
```

```{r studentwavetable-check}
gradethis::grade_result(
  pass_if(~ {nrow(.result) == 480 && ncol(.result) == 12 }, "Indeed, student, bestfriend, bfperiod, and bfwave belong together in this tibble."),
  fail_if(~ nrow(.result) != 480, "The number of cases in the new tibble is not correct. You did not select the correct variables."),
  fail_if(~ ncol(.result) != 12, "The number of variables in the new tibble is not correct. You did not select (all) correct variables.")
)
```

### 

<div class="question">
3. StudentBestfriend.
</div>

```{r bestfriendstable, exercise = TRUE, exercise.lines = 6}
# Your code to create a tibble for best friends information without duplicates.
StudentBestfriend <- GlasgowFriends |> 
  # select the relevant variables
  select( ____ ) |> 
  # only keep cases that are distinct (not identical)
  distinct()
```

<!-- To hide the solution, use a textual hint. -->
<div id="bestfriendstable-hint">
__Hint:__ Include the `student` variable, otherwise we don't know who nominated the best friend.
</div>

```{r bestfriendstable-solution, exercise.setup = "studentwavetable-solution"}
StudentBestfriend <- GlasgowFriends |> select(student, bestfriend, bfperiod, bfwave ) |> distinct()
```

```{r bestfriendstable-check}
gradethis::grade_result(
  pass_if(~ {nrow(.result) == 519 && ncol(.result) == 4 }, "Indeed, student, bestfriend, bfperiod, and bfwave belong together in this tibble."),
  fail_if(~ nrow(.result) != 519, "The number of cases in the new tibble is not correct. You did not select the correct variables."),
  fail_if(~ ncol(.result) != 4, "The number of variables in the new tibble is not correct. You did not select (all) correct variables.")
)
```

### 

Within the student tibble, the neighbourhood information is repeated:

- Neighbourhood is a type of cases that should be split off into a separate tibble.
- You know how to do that by now.

### Foreign key, one-to-many vs. many-to-many relations

Primary keys link the new tibbles that we split off:

-   `student` ("s001", "s002", ...) links the *Student* tibble to *StudentWave* and *StudentBestFriend*.
-   `neighbourhood` links the *Student* and *Neighbourhood* tibbles. 

```{r diagram0, out.width="60%", fig.asp=0.5, fig.cap="Figure. Relations between the tibbles. Variables that are (part of) the primary key of a tibble are underlined."}
library(DiagrammeR)
DiagrammeR::grViz("
digraph database {
    graph [rankdir = LR]
    node [
      shape=plaintext
      fontname = 'Helvetica'
    ]
    Student [label=<
<TABLE BORDER='0' CELLBORDER='1' CELLSPACING='0'>
  <TR><TD BGCOLOR='black'><FONT COLOR='white'>Student</FONT></TD></TR>
  <TR><TD PORT='f1'><U>student</U></TD></TR>
  <TR><TD PORT='f2'>neighbourhood</TD></TR>
  <TR><TD>age</TD></TR>
  <TR><TD>sex</TD></TR>
  <TR><TD>smoking_at_home</TD></TR>
  <TR><TD>smoking_parents</TD></TR>
  <TR><TD>smoking_siblings</TD></TR>
</TABLE>>];
    StudentBestfriend [label=<
<TABLE BORDER='0' CELLBORDER='1' CELLSPACING='0'>
  <TR><TD BGCOLOR='black'><FONT COLOR='white'>StudentBestfriend</FONT></TD></TR>
  <TR><TD PORT='f1'><U>student</U></TD></TR>
  <TR><TD><U>bestfriend</U></TD></TR>
  <TR><TD>bfperiod</TD></TR>
  <TR><TD>bfwave</TD></TR>
</TABLE>>];
    Neighbourhood [label=<
<TABLE BORDER='0' CELLBORDER='1' CELLSPACING='0'>
  <TR><TD BGCOLOR='black'><FONT COLOR='white'>Neighbourhood</FONT></TD></TR>
  <TR><TD PORT='f1'><U>neighbourhood</U></TD></TR>
  <TR><TD>schooldist</TD></TR>
  <TR><TD>hoodname</TD></TR>
</TABLE>>];
    StudentWave [label=<
<TABLE BORDER='0' CELLBORDER='1' CELLSPACING='0'>
  <TR><TD BGCOLOR='black'><FONT COLOR='white'>StudentWave</FONT></TD></TR>
  <TR><TD PORT='f1'><U>student</U></TD></TR>
  <TR><TD PORT='f2'><U>wave</U></TD></TR>
  <TR><TD>alcohol</TD></TR>
  <TR><TD>cannabis</TD></TR>
  <TR><TD>money</TD></TR>
  <TR><TD>romantic</TD></TR>
</TABLE>>];
    Neighbourhood:f1 -> Student:f2 ;
    Student:f1 -> StudentBestfriend:f1;
    Student:f1 -> StudentWave:f1
}
")
```

_Foreign key_: 

-   Variable that is a primary key in another tibble.
-   Examples: `neighbourhood` in the *Student* tibble; `student` in the *StudentWave* tibble.

Types of relations between tibbles:

1.    _One-to-many relation_: A student is living in only one neighbourhood (at least in this data set) even though many students can live in the same neighbourhood.

2. _Many-to-many relation_: A student may appear in many waves and a wave may include many students. 

Not every many-to-many relation is picked up by the primary key (see next topic).

## 2. Each observation must have its own row.

For each student in each wave, up to six friends could be mentioned. 

```{r showfriends}
GlasgowFriends |> 
  select(student, wave, friend_1, friend_2, friend_3, friend_4, friend_5, friend_6 ) |> 
  distinct() |>
  slice(1:6) |>
  kable(booktabs = TRUE) |>
  kableExtra::kable_classic(full_width = FALSE) |>
  kableExtra::column_spec(4, color = c("red", "black", "black", "red", "black", "black")) |>
  kableExtra::column_spec(5, color = c("black", "black", "red", "black", "black", "black"))
```

Problems:

- Many cells with missing values (`NA`). Waste of space!
- The same student may appear in each of the six friendship variables (e.g., `s028`). Hard to count!
- The variable names contain a number (`friend_1`, `friend_2`, ...). But numbers are values (first mentioned friend, second mentioned friend, ...). How can we use these?

### 

### 

The tidy solution:

-   Stack repeated information. 
-   Yields one row (observation) per student per wave per nominated friend.

```{r showfriendsgathered}
GlasgowFriends |> 
  select(student, wave, friend_1, friend_2, friend_3, friend_4, friend_5, friend_6 ) |>
  gather(key = "friendnumber", value = "friend", friend_1:friend_6, na.rm = TRUE) |>
  distinct() |>
  arrange(student, wave, friendnumber) |>
  slice(1:6) |>
  kable(booktabs = TRUE) |>
  kableExtra::kable_classic(full_width = FALSE) |>
  kableExtra::column_spec(4, color = c("black", "red", "black", "black", "black", "black"))
```

<div class="question" >
Use the tidyverse `pivot_longer()` function to create a new tibble named `StudentWaveFriend` containing one row (observation) per student per wave per nominated friend. The tibble should only contain the same variables as in the above table.
</div>

```{r gatherfriends, exercise = TRUE, exercise.setup = "studentwavetable-solution"}
StudentWaveFriend <- StudentWave |> 
  pivot_longer( ____ ) |>
  select()
#Show result.
StudentWaveFriend
```

<div id="gatherfriends-hint">
__Hint:__ Use help on the pivot_longer() function   .
</div>

```{r gatherfriends-solution}
StudentWaveFriend <- StudentWave |> pivot_longer( friend_1:friend_6, names_to = "friendnumber", values_to = "friend", values_drop_na = TRUE ) |> select( student, wave, friendnumber, friend )
```

```{r gatherfriends-check}
gradethis::grade_result(
  fail_if(~ nrow(StudentWaveFriend) > 1600, "Did you remove the rows with missing values for the friend variable? These rows are superfluous. Use an argument in the `gather()` function to remove the rows."),
  fail_if(~ ("alcohol" %in% names(StudentWaveFriend)) | ("cannabis" %in% names(StudentWaveFriend)) | ("money" %in% names(StudentWaveFriend)) | ("romantic" %in% names(StudentWaveFriend)), "Drop the student characteristics that have only one value per student per wave: alcohol, cannabis, and so on. Why are they untidy in the new tibble?"),
  fail_if(~ ncol(StudentWaveFriend) < 4, "Did you select the relevant variables in the end: student, wave, and friend?"),
  pass_if(~ TRUE, "You retained the cases and variables that matter.")
)
```

###

<div class="question" >
Oh, and remove the friendship data from tibble `StudentWave`.
</div>

```{r gatherfriends2, exercise = TRUE, exercise.setup = "studentwavetable-solution"}
StudentWave <- StudentWave |> 
  ???
```

<div id="gatherfriends-hint">
__Hint:__ How about using the select() function?
</div>

```{r gatherfriends2-solution, eval=FALSE}
StudentWave <- StudentWave |> select(student:romantic)
```

```{r gatherfriends2-check}
gradethis::grade_result(
  fail_if(~ str_starts(names(StudentWave)[ncol(StudentWave)], "friend"), "There is still a friendship variable in the `StudentWave` tibble. Did you not overwrite this tibble?"),
  pass_if(~ ncol(StudentWave) == 6, "")
)
```

### Optional: `pivot_longer()` exercise

```{r pivotlonger-setup}
# create a tibble with waves as different columns
GlasgowWide <- UsingRTutorials::Glasgow |>
  pivot_wider(id_cols = student:smoking_siblings, names_from = wave, values_from = alcohol:friendships)
```

Tibble `GlasgowWide` contains the data in the original panel wave format. (This tibble is loaded in this tutorial.)

<div class="question" >
Use the `pivot_longer()` function to gather the information measured per wave in tibble `GlasgowWide`: smoking, alcohol, cannabis, and tobacco use, pocket money, romantic relations, and number of friendships. 
</div>

Note: Send the gathered tibble to the screen, do not store it in a new data object (so the code checker can do its work).

```{r pivotlonger, exercise = TRUE}
# Tip: Have a look at the data first.
GlasgowWide

```

<div id="pivotlonger-hint">
__Hint:__ Read the vignette: Issue the R command `vignette("pivot")`. Look for the part on multiple observations per row.
</div>

```{r pivotlonger-solution}
GlasgowWide |> pivot_longer(cols = alcohol_t2:friendships_t1, names_to = c(".value", "wave"), names_sep = "_")
```

```{r pivotlonger-check}
gradethis::grade_code(
  correct = "", 
  incorrect = "Carefully read the part on multiple observations per row in the pivot vignette."
  )
```

## 3. Each variable must have its own column.  

### 

Inspect the tibble `StudentBestfriend` that you created previously. 

<div class="question" >
Is there a variable with values that should be variables by themselves?
</div>

```{r owncolumn, eval = TRUE, echo = FALSE}
GlasgowFriends |> 
  select(student, bestfriend, bfperiod, bfwave ) |> 
  distinct()|>
  slice(1:10) |>
  kable(booktabs = TRUE) |>
  kableExtra::kable_classic(full_width = FALSE)
```

### 

Values in variable `bfperiod` are variable names:

-   `from`: wave in which the student mentioned a peer as best friend for the first time;
-   `to`: idem, for the last time (`to`). 
-   The actual value for `from` and `to` are stored in the `bfwave` variable.

<div class="emphasis" >
Tidy Rule 3. Each variable must have its own column.
</div>

###

Tidy data: tibble with variables `from`and `to` instead of `bfperiod` and `bfwave`.

```{r owncolumn2, eval = TRUE, echo = FALSE}
GlasgowFriends |> 
  select(student, bestfriend, bfperiod, bfwave ) |> 
  distinct()|>
  # students without best friend are dropped
  filter(!is.na(bestfriend)) |>
  # spread the bfperiod values into new variables
  pivot_wider(id_cols = student:bestfriend, names_from = bfperiod, values_from = bfwave) |>
  arrange(student, bestfriend) |>
  slice(1:6) |>
  kable(booktabs = TRUE) |>
  kableExtra::kable_classic(full_width = FALSE)
```

<div class="question" >
Replace the `StudentBestfriend` tibble by a tibble with variables `from` and `to` instead of `bfperiod` and `bfwave`.
</div>

```{r gatherBestfriend, exercise = TRUE, eval=FALSE, exercise.setup = "bestfriendstable-solution"}
StudentBestfriend <- StudentBestfriend |>
  # students without best friend are dropped
  ____( ____ ) |>
  # spread the bfperiod values into new variables
  pivot_wider( ____ )
# Show result.
StudentBestfriend
```

```{r gatherBestfriend-solution, exercise.reveal_solution = FALSE}
StudentBestfriend <- StudentBestfriend |> filter(!is.na(bestfriend)) |> pivot_wider(id_cols = student:bestfriend, names_from = bfperiod, values_from = bfwave)
```

```{r gatherBestfriend-hint-1}
# Drop cases (filter()) with missing values on bestfriend (function is.na()).
```

```{r gatherBestfriend-hint-2}
# Within pivot_wider() function, use arguments: id_cols, names_from, and values_from.
```

```{r gatherBestfriend-hint-3}
# Check out the vignette: issue the R command `vignette("pivot")` in RStudio.
```

```{r gatherBestfriend-check}
gradethis::grade_result(
  fail_if(~ "NA" %in% names(StudentBestfriend), "Missing values become a new variable too. Remove them first."),
  fail_if(~ !("from" %in% names(StudentBestfriend)), "I guess that you spread the wrong variable. It should be `bfperiod`."),
  fail_if(~ !("t1" %in% StudentBestfriend$from), "Did you retrieve the values of the new variables from `bfwave`?"),
  pass_if(~ TRUE, "You removed missing values correctly and spread the `bfperiod` variable, using `bfwave`for the new values.")
)
```

## 4. Each value must have its own cell. 

Split a variable containing more than one piece of information.

Trivial example, variable `alcohol` with values containing both a numeric code and a label:

-   `1 none`;
-   `2 once or twice a year`;
-   `3 once a month`;
-   and so on.

<div class="question" >
Write tidyverse code to split the `alcohol` variable in the `StudentWave` tibble into a numeric variable `alcohol_code` and a character variable `alcohol_label`.
</div>

Note: Send the results to the screen, do not store it in a new data object (so the code checker can do its work).

```{r separate, exercise = TRUE, exercise.setup = "studentwavetable-solution"}
StudentWave |> 
  separate()
```

```{r separate-solution, exercise.reveal_solution = FALSE}
StudentWave |> separate(col = alcohol, into = c("alcohol_code", "alcohol_label"), sep = 2)
```

```{r separate-hint-1}
# Within separate() function, use arguments: col, into, and sep.
```

```{r separate-hint-2}
# The into argument requires a vector (c()) with names for the new variables to be created.
```

```{r separate-hint-3}
# It is easiest here to separate the original value using the character position: split at the second position (from the left).
```

```{r separate-check}
gradethis::grade_code(
  correct = "", 
  incorrect = "You cannot split on a particular character, such as a blank, because you would get more than two parts. Only the first part of the alcohol label will be used. Separate on position number: At which character number do you want to split?"
  )
```

This concludes data tidying.

## Meet the Experts

###

-   You need to know about and apply all tidy data principles. 
-   To help you get there, we will engage in peer-learning.

<div class="emphasis">
HOMEWORK BEFORE SESSION 4: Become an expert in 1 out of the 4 tidy data principles.
</div>

“Becoming an expert" means:

-   Re-visit the tidy data principle in the book and course materials.
-   Apply it to one of your Data Project data sets. 
-   Produce 2 PowerPoint slides (use the template in Session 4 module on Canvas).

###

Slide 1: explain the tidy data principle in your own words, using 3 questions:

-   WHAT type of data structure the tidy data principle refers to (What does untidy and what does tidy data look like?) 
-   HOW the tidy data principle can be implemented using R code.
-   WHY the tidy data principle creates tidy data that is easier to work with than untidy data.

### 

Slide 2: visualize the application of the tidy data principle to your Data Project dataset:

-   Include a screenshot of the data (only relevant variables) in it’s untidy form.
-   Include a screenshot of the data in it’s tidy form.
-   Include the R code you used to tidy the data.

### Assigning students to tidy data principles

For your complex data sets, ask yourself one of the following:

1.    Does the data set contain info on more than one type of unit?
      +   Or: Is the same information repeated in different rows?
      +   If so, transfer the info on each type of unit to a separate table.
      
2.    Do different variables address the same information?
      +   If so, gather (pivot_longer()) repeated information into one variable.

3.    Is there a variable with values that should be variables by themselves?
      +   If so, spread (pivot_wider) the values into variables.

4.    Does a variable contain more than one piece of information?
      +   If so, separate the pieces into different variables.
      
## Joins (relational Database) Principles

### 

As a result of tidying the `GlasgowFriends` tibble, we now have several tibbles:

-   `Student`, 
-   `StudentWave`, 
-   `StudentWaveFriend`, 
-   `StudentBestfriend`, 
-   `Neighbourhood`.

Every piece of information is now stored in just one spot, which is efficient and least error prone.

### 

However, when we want to analyze data, we may need information from different tibbles. To this end, tidyverse offers us four join functions:

- `left_join()`
- `right_join()`
- `inner_join()`
- `full_join()`

These functions may yield different results, most notably, different numbers of cases. 

```{r eval=FALSE}
Student |> left_join(StudentBestfriend, by = "student")
Student |> right_join(StudentBestfriend, by = "student")
Student |> inner_join(StudentBestfriend, by = "student")
StudentBestfriend |> inner_join(Student, by = "student")
Student |> full_join(StudentBestfriend, by = "student")
```

### 

<div class="question" >
Use the below code box to join the `Student` and `StudentBestfriend` tibbles with each of the four joins. 

* Do you get the same number of cases (rows) with all joins?
* Compare the number of cases with those of the `Student` tibble (`r nrow(Student)` rows) and the `StudentBestfriend` tibble (`r GlasgowFriends |> 
  select(student, bestfriend, bfperiod, bfwave ) |> distinct() |>
  filter(!is.na(bestfriend)) |> 
  pivot_wider(id_cols = student:bestfriend, names_from = bfperiod, values_from = bfwave) |> nrow()` rows). Why is it equal, larger, or smaller than in the original tables?
</div>

```{r join1-setup}
# Create the definitive StudentBestfriend tibble.
StudentBestfriend <- GlasgowFriends |> 
  select(student, bestfriend, bfperiod, bfwave ) |> distinct() |>
  filter(!is.na(bestfriend)) |> 
  pivot_wider(id_cols = student:bestfriend, names_from = bfperiod, values_from = bfwave)
```

```{r join1, exercise = TRUE}
# Select different join types. Also switch the two tibbles.
Student |>
  left_join(StudentBestfriend, by = "student")
# Note the resulting number of cases in the bottom-left of the table.
```

```{r join1-hint-1}
# Join the two tibbles, using `student` as key.
# Start, for example, with a left join:
Student |> left_join(StudentBestfriend, by = "student")
```

###

Graphical examples of what happens with the four different joins:

- A left join that joins `StudentBestFriend` to `Student`:
    `Student |> left_join(StudentBestfriend, by = "student")`
```{r out.width="80%"}
knitr::include_graphics("images/Leftjoin.png")
```

-   Each row (case) in the first (left) tibble is preserved in the resulting tibble.
-   In addition, each row in the second (right) tibble with a match in the first tibble is preserved.

### 

- A right join that joins `StudentBestFriend` to `Student`:
    `Student |> right_join(StudentBestfriend, by = "student")`
```{r out.width="80%"}
knitr::include_graphics("images/Rightjoin.png")
```

-   Like a `left_join()` but now with the tibbles reversed.

### 

- An inner join that joins `StudentBestFriend` to `Student` or the other way around:
    `Student |> inner_join(StudentBestfriend, by = "student")`
    `StudentBestfriend |> inner_join(Student, by = "student")`
```{r out.width="80%"}
knitr::include_graphics("images/Innerjoin.png")
```

-   Only rows with key values that appear in both tibbles are preserved.

### 

- A full join that joins `StudentBestFriend` to `Student`:
    `Student |> full_join(StudentBestfriend, by = "student")`

```{r out.width="80%"}
knitr::include_graphics("images/Fulljoin.png")
```

-   All rows of both tibbles are preserved.

### Check the join results

A.    Determine the primary key of the joined tibble. What are you counting when you count cases?  

B.    Did you have missing values on key variables used for the join? Do you want these cases in the joined tibble?  

C.    Which cases from the original tibbles are NOT included in the joined tibble. Is this as you want it to be?  

### Ad A. Determining the primary key.

You have learned this earlier in this tutorial.

Does the primary key make sense? Do you understand what you are counting?

### Ad B. Checking for missing values on a join key

Missing values on a variable used as join key may yield many new cases or missing values in the joined tibble.

```{r join1b-setup}
# Create the StudentBestfriend tibble with some missing values for bestfriend.
StudentBestfriend2 <- GlasgowFriends |> 
  select(student, bestfriend, bfperiod, bfwave ) |> distinct() |>
#  filter(!is.na(bestfriend)) |> 
  pivot_wider(id_cols = student:bestfriend, names_from = bfperiod, values_from = bfwave)

# Create the StudentWave tibble.
StudentWave <- GlasgowFriends |> select(student, wave, alcohol, cannabis, money, romantic, friend_1, friend_2, friend_3, friend_4, friend_5, friend_6 ) |> distinct()
```

<div class="question" >
Count the number of missing values on variable `bestfriend` in the tibble *StudentBestfriend2* and in the tibble *AlcoholComparison*. What has happened and why?
</div>

```{r join1b, exercise = TRUE, exercise.lines = 19}
# Count the number of missing values on join key variable bestfriend 
# in the StudentBestfriend tibble.
StudentBestfriend2 |> 
  summarise( ____ )
# Join StudentBestFriend with StudentWave to compare alcohol use 
# of a student to their best friends' alcohol use.
AlcoholComparison <- StudentBestfriend2 |>
  # add alcohol use for the friendship nominator
  left_join(StudentWave, by = "student") |>
  # just keep the alcohol use and wave info
  select( student:to, studentWave = wave, studentAlcohol = alcohol) |>
  # same for nominate best friend
  left_join(StudentWave, by = c("bestfriend" = "student")) |>
  # just keep the alcohol use and wave info
  select( student:studentAlcohol, friendWave = wave, friendAlcohol = alcohol)
# Count the number of missing values on join key variable bestfriend 
# in the StudentBestfriend tibble.
AlcoholComparison |> 
  summarise( ____ )
```

```{r join1b-hint-1}
# Remember how to count the number of missing values?
# For example, use sum(is.na()) within summarise().
```

```{r join1b-hint-2}
# For the StudentBestfriend tibble, replace ____ by one the join key variable(s).
StudentBestfriend2 |> 
  summarise(
    n_missing_bestfriend = sum(is.na( ____ ))
    )
```

```{r join1b-hint-3}
# Have a look at the cases with a missing value on `bestfriend` in the joined table to understand what has happened.
```

### Ad C. Checking join key overlap: `anti_join()`

Which cases from the original tibbles are NOT included in the joined tibble. Is this as you want it to be?

```{r join2-setup}
# Create the definitive StudentBestfriend tibble.
StudentBestfriend <- GlasgowFriends |> 
  select(student, bestfriend, bfperiod, bfwave ) |> distinct() |>
  filter(!is.na(bestfriend)) |> 
  pivot_wider(id_cols = student:bestfriend, names_from = bfperiod, values_from = bfwave)

# Create the StudentWave tibble.
StudentWave <- GlasgowFriends |> select(student, wave, alcohol, cannabis, money, romantic, friend_1, friend_2, friend_3, friend_4, friend_5, friend_6 ) |> distinct()
```

For example, are all students from the *Student* tibble included in the joined tibble comparing a student's alcohol use with their best friends' alcohol use?

<div class="question">
Use the `anti_join()` function to find the students registered in tibble *Student* but not in tibble *AlcoholComparison* or the other way around.

How many student are missing in one of the two tibbles?
</div>

```{r join2, exercise = TRUE}
# Join StudentBestFriend with StudentWave to compare alcohol use 
# of a student to their best friends' alcohol use.
AlcoholComparison <- StudentBestfriend |>
  # add alcohol use for the friendship nominator
  left_join(StudentWave, by = "student") |>
  # just keep the alcohol use and wave info
  select( student:to, studentWave = wave, studentAlcohol = alcohol) |>
  # same for nominate best friend
  left_join(StudentWave, by = c("bestfriend" = "student")) |>
  # just keep the alcohol use and wave info
  select( student:studentAlcohol, friendWave = wave, friendAlcohol = alcohol) |>
  # (NEW) only keep alcohol use in the same wave
  filter(studentWave == friendWave)
# Select cases that appear in one table but not the other.
____ |> anti_join( ____ , by = "____" )
```

<!-- To hide the solution, use a textual hint. -->
<div id="join2-hint">
__Hint:__ The order of tibbles in the anti_join() function matters. Try both orders: matching `Student` to `AlcoholComparison` and the other way around. 
</div>

```{r join2-solution}
AlcoholComparison <- StudentBestfriend |>
  # add alcohol use for the friendship nominator
  left_join(StudentWave, by = "student") |>
  # just keep the alcohol use and wave info
  select( student:to, studentWave = wave, studentAlcohol = alcohol) |>
  # same for nominate best friend
  left_join(StudentWave, by = c("bestfriend" = "student")) |>
  # just keep the alcohol use and wave info
  select( student:studentAlcohol, friendWave = wave, friendAlcohol = alcohol) |>
  # (NEW) only keep alcohol use in the same wave
  filter(studentWave == friendWave)
Student |> anti_join(AlcoholComparison, by = "student")
```

```{r join2-check}
gradethis::grade_code(
  correct = "All students in tibble `AlcoholComparison` appear in tibble `Student`, but not the other way around.", 
  incorrect = "Swap the order of tibbles. Perhaps that may work."
  )
```

### Recognizing untidy data tidying

<div class="tip" >
__Programming Tips__

- If the number of observations for a variable is larger than you should expect given the description of the data, you probably have to split tibbles.
- If your R code is complicated when you want to do a simple thing, your data are probably in wide format, while tidy data are in long format.
</div>

## Fancy Stuff

### Contingency tables (crosstabs)

Another application of spreading: cross-tabulation. A contingency table of two variables has variable values in rows and columns. 

<div class="question" >
Add comments to the code explaining each step of the pipe.
</div>

```{r crosstabs1-setup}
Student <- GlasgowFriends |> 
  select(student, neighbourhood, schooldist, hoodname, age, sex, smoking_at_home, smoking_parents, smoking_siblings) |> 
  distinct()
StudentWave <- GlasgowFriends |> 
  select(student, wave, alcohol, cannabis, money, romantic, friend_1, friend_2, friend_3, friend_4, friend_5, friend_6 ) |> 
  distinct()
```

```{r crosstabs1, exercise = TRUE, exercise.eval = TRUE}
# alcohol use by wave crosstabs from original dataset
GlasgowFriends |>
  distinct(student, wave, alcohol) |>
  count( wave, alcohol ) |>
  pivot_wider(names_from = wave, values_from = n) |>
  knitr::kable(booktab = FALSE) |>
  kableExtra::kable_styling(full_width = FALSE)
```

<div id="crosstabs1-hint">
__Hint:__ If you want to know the result of a step in the pipe, send the intermediate result to the screen or to View().
</div>

###

Let us go one step further. Let us use our knowledge about the `kableExtra` package from Session 2.

<div class="question" >
Play around with (more) `kableExtra` settings.
</div>

```{r crosstabs2-setup}
Student <- GlasgowFriends |> 
  select(student, neighbourhood, schooldist, hoodname, age, sex, smoking_at_home, smoking_parents, smoking_siblings) |> 
  distinct()
StudentWave <- GlasgowFriends |> 
  select(student, wave, alcohol, cannabis, money, romantic, friend_1, friend_2, friend_3, friend_4, friend_5, friend_6 ) |> 
  distinct()
```

```{r crosstabs2, exercise = TRUE, exercise.eval = TRUE}
StudentWave |> 
  left_join(Student, by = "student") |> 
  count( sex, wave, alcohol ) |> 
  pivot_wider(names_from = c(sex, wave), values_from = n, values_fill = 0) |> 
  kable(booktab = TRUE, col.names = c("Alcohol Usage", "wave 1", "wave 2", "wave 3", "wave 1", "wave 2", "wave 3")) |> 
  add_header_above(c(" " = 1, "Boys" = 3, "Girls" = 3)) |> 
  kable_paper(full_width = FALSE)
```

<div id="crosstabs2-hint">
__Hint:__ 

-   For the layout, use the [kableExtra webpage](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html).
-   Note the column names are partly defined in the `kable()` function and partly in a `kableExtra` function.
</div>

### Networks

Many-to-many relations can be visualized as networks. Friendship nominations among students can be depicted with nodes representing students and arrows showing friendship nominations.

The `StudentWaveFriend` tibble contains all the information that we need to draw a friendship network for the Glasgow data:

-   Variable `student` in this tibble represents the student nominating a friend.
-   Variable `friend` represents the student nominated. 

A line in a network is just a pair of nodes!

There are many R packages for network visualization and network analysis or modelling. [Network visualization with R](https://kateto.net/network-visualization) offers a tutorial on some R packages for network visualization. The examples below use the `igraph` package.

<div class="question" >
Use the tutorial referenced above and the `igraph` documentation to play around with the friendship network in wave1.
</div>

```{r network1-setup}
#preparing data tibbles for network
Student <- GlasgowFriends |> select(student, neighbourhood, schooldist, hoodname, age, sex, smoking_at_home, smoking_parents, smoking_siblings) |> distinct()
StudentWave <- GlasgowFriends |> select(student, wave, alcohol, cannabis, money, romantic, friend_1, friend_2, friend_3, friend_4, friend_5, friend_6 ) |> distinct()
StudentWaveFriend <- StudentWave |> 
  gather(key = "friendnumber", value = "friend", friend_1:friend_6, na.rm = TRUE) |>
  select(student, wave, friend)
```


```{r network1, exercise = TRUE, exercise.lines = 20, exercise.eval = TRUE, fig.asp=0.5, out.width="100%", fig.cap="Figure: Friendship nominations at the first wave. Mutual nominations are black, unilateral nominations are orange."}
# Install the igraph package (once).
# install.packages("igraph")
# Load the igraph package.
library(igraph)
# Retrieve the friendship nominations in the first wave and ensure that the
# first two columns are the sender and receiver of the nomination.
arrows_wave1 <- StudentWaveFriend |>
  filter(wave == "t1") |>
  select(student, friend)
#add color variable for sexes
nodes_wave1 <- Student |>
  mutate(sex_color = ifelse(sex == "boy", "steelblue1", "tomato1"))
# Create an igraph object: a list of nodes (=vertices) combined with a list of lines/arrows.
net_wave1 <- igraph::graph_from_data_frame(d=arrows_wave1, vertices=nodes_wave1, directed=TRUE)

# Create a layout: positioning of the nodes.
set.seed(35546)
layout_1 <- igraph::layout_with_fr(net_wave1)
# Spread out the network horizontally.
layout_1 <- igraph::norm_coords(layout_1, ymin=-1, ymax=1, xmin=-2, xmax=2)
# Plot the network.
par(mar = c(0, 0, 0, 0))
plot(net_wave1, 
     vertex.label = NA, #hide node labels
     vertex.size = 8, #vertex size
     vertex.color = V(net_wave1)$sex_color,
     edge.arrow.size=.4, # arrowhead size
     #give reciprocal arrows (edges) a different colour than unilateral arrows:
     edge.color = ifelse(which_mutual(net_wave1), "gray40", "tan1"),
     rescale = FALSE, #don't rescale to square network
     layout = layout_1 #use the previously created node coordinates
     )
legend("topleft", c("Boys", "Girls"), pch=21, col="#777777", pt.bg=c("steelblue1", "tomato1"), pt.cex=2, cex=.8, bty="n", ncol=1)
```

### Joins (Relational) database diagram

Talking about networks: A relational database is a network of tables (tibbles) and joins between tables. To the best of my knowledge, packages for network analysis cannot display tables. The R package `DiagrammeR`, which uses [graphviz](http://www.graphviz.org/), can do this.

```{r diagram1, exercise = TRUE, exercise.eval = TRUE}
#After installing the DiagrammeR package, load it.
# install.packages("DiagrammeR")
library(DiagrammeR)

DiagrammeR::grViz("
digraph database {
graph [
rankdir = 'LR'
];
node [
fontsize = '16'
shape = 'ellipse'
];
edge [
];
'node1' [
label = 'Student | <f1> student | <f2> neighbourhood | age | sex |smoking_at_home | smoking_parents | smoking_siblings'
shape = 'record'
];
'node2' [
label = 'Neighbourhood | <f1> neighbourhood | schooldist | hoodname'
shape = 'record'
];
'node3' [
label = 'StudentBestfriend | <f1> student | bestfriend | from | to'
shape = 'record'
];
'node4' [
label = 'StudentWave | <f1> student | <f2> wave | alcohol | cannabis | money | romantic'
shape = 'record'
];
'node5' [
label = 'StudentWaveFriend | <f1> student | <f2>wave | friend'
shape = 'record'
];
'node2':f1 -> 'node1':f2;
'node1':f1 -> 'node3':f1;
'node1':f1 -> 'node4':f1;
'node1':f1 -> 'node5':f1;
'node4':f2 -> 'node5':f2;
}
")
```

### 

With this concise definition of the tables, it is not possible to change the background colour of a the first table row indicating the table name or use underlining to mark the variables that constitute the primary key of a table.

For such fine-tuning, we have to use HTML code.

```{r diagram2, exercise = TRUE, exercise.eval = TRUE}
library(DiagrammeR)
DiagrammeR::grViz("
digraph database {
    graph [rankdir = LR]
    node [
      shape=plaintext
      fontname = 'Helvetica'
    ]
    Student [label=<
<TABLE BORDER='0' CELLBORDER='1' CELLSPACING='0'>
  <TR><TD BGCOLOR='black'><FONT COLOR='white'>Student</FONT></TD></TR>
  <TR><TD PORT='f1'><U>student</U></TD></TR>
  <TR><TD PORT='f2'>neighbourhood</TD></TR>
  <TR><TD>age</TD></TR>
  <TR><TD>sex</TD></TR>
  <TR><TD>smoking_at_home</TD></TR>
  <TR><TD>smoking_parents</TD></TR>
  <TR><TD>smoking_siblings</TD></TR>
</TABLE>>];
    Neighbourhood [label=<
<TABLE BORDER='0' CELLBORDER='1' CELLSPACING='0'>
  <TR><TD BGCOLOR='black'><FONT COLOR='white'>Neighbourhood</FONT></TD></TR>
  <TR><TD PORT='f1'><U>neighbourhood</U></TD></TR>
  <TR><TD>schooldist</TD></TR>
  <TR><TD>hoodname</TD></TR>
</TABLE>>];
    StudentBestfriend [label=<
<TABLE BORDER='0' CELLBORDER='1' CELLSPACING='0'>
  <TR><TD BGCOLOR='black'><FONT COLOR='white'>StudentBestfriend</FONT></TD></TR>
  <TR><TD PORT='f1'><U>student</U></TD></TR>
  <TR><TD><U>bestfriend</U></TD></TR>
  <TR><TD>from</TD></TR>
  <TR><TD>to</TD></TR>
</TABLE>>];
    StudentWave [label=<
<TABLE BORDER='0' CELLBORDER='1' CELLSPACING='0'>
  <TR><TD BGCOLOR='black'><FONT COLOR='white'>StudentWave</FONT></TD></TR>
  <TR><TD PORT='f1'><U>student</U></TD></TR>
  <TR><TD PORT='f2'><U>wave</U></TD></TR>
  <TR><TD>alcohol</TD></TR>
  <TR><TD>cannabis</TD></TR>
  <TR><TD>money</TD></TR>
  <TR><TD>romantic</TD></TR>
</TABLE>>];
    StudentWaveFriend [label=<
<TABLE BORDER='0' CELLBORDER='1' CELLSPACING='0'>
  <TR><TD BGCOLOR='black'><FONT COLOR='white'>StudentWaveFriend</FONT></TD></TR>
  <TR><TD PORT='f1'><U>student</U></TD></TR>
  <TR><TD PORT='f2'><U>wave</U></TD></TR>
  <TR><TD><U>friend</U></TD></TR>
</TABLE>>];
    Neighbourhood:f1 -> Student:f2;
    Student:f1 -> StudentBestfriend:f1;
    Student:f1 -> StudentWave:f1;
    Student:f1 -> StudentWaveFriend:f1;
    StudentWave:f2 -> StudentWaveFriend:f2
}
")
```

### A geographic network

With `ggplot()` and the `map::` package, we can plot geographical networks.

For example, the flights to/from NY City in the `nycflights13::` (example data in the book).

```{r nycflightsmap, exercise = TRUE, exercise.eval = TRUE}
# Load the nycflights13 package.
library(nycflights13)
# Connect the flights (origin & destination) and airports tables (airport coordinates).
flights |> #use the flights tibble in the nycflights13 package
  #add coordinates to airport where flight originates
  inner_join(select(airports, origin = faa, origin_lat = lat, origin_lon = lon), 
             by = "origin") |>
  #add coordinates to destination airport
  inner_join(select(airports, dest = faa, dest_lat = lat, dest_lon = lon), by = "dest"
  ) |>
  # select the first 100 flights for illustrative purposes
  slice(1:100) |>
  # pipe the data into ggplot()
  ggplot(aes(
    x = origin_lon, xend = dest_lon,
    y = origin_lat, yend = dest_lat
    )) +
    borders("state") +
    geom_segment(arrow = arrow(length = unit(0.1, "cm"))) +
    coord_quickmap() +
    labs(y = "Latitude", x = "Longitude")
```

## Thursday Reading

Chapter 14,15: Strings. Read to see the possibilities, so you know where to
find commands that are relevant to your Data Project.

Chapter 16: Factors. Study carefully. Categorical variables are used as
factors in statistical analyses.

Chapter 17: Dates and Times. Study carefully, especially if your complex
data contain dates/times.

## Data Project

<div class="emphasis" >
Today:

-   15 minute expert meeting on data tidying.
-   Discuss expert meeting or save notes until Sprint 3.
-   Keep working on Sprint 2,
-   Brief consultations.
</div>

Tips for your current or upcoming Sprint Backlog: With the skills discussed
today, you can:

-   Check and tidy your complex data sets.
-   Check which of your complex data sets can be linked.
-   Use `dplyr::` and `tidyr::` to link data.
-   Summarize the contents and relations between your data sets in your Data Project R
Markdown file.
-   Plan in some time for everybody to practice with `ggplot()` on the Data
Project.
